# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**RO_FastDelivery**: Two-stage robust supply chain optimization using Column-and-Constraint Generation (C&CG) algorithm. Solves a three-echelon distribution network problem (Plants → DCs → Customers) with bidirectional demand uncertainty and endogenous demand influenced by transportation mode selection.

## Core Architecture

### Problem Structure
- **Three-echelon network**: 5 Plants → 20 DCs → 100 Customers
- **Products**: 3 product types
- **Transport modes**: 3 modes (affects delivery speed and demand)
- **Uncertainty**: Bidirectional demand uncertainty (increases and decreases)
- **Two-stage decisions**:
  - **First-stage** (strategic): Facility opening, route selection, mode assignment
  - **Second-stage** (operational): Production quantities, flows, shortages

### Main Components

**DH_config.py**: Configuration and parameter settings
- `ProblemConfig`: Problem dimensions and algorithm settings
  - Toy instance: K=1, I=2, J=2, R=5, M=2
  - Full instance: K=3, I=5, J=20, R=100, M=3
  - Convergence tolerance: ε = 1e-4
  - Max iterations: 100
- `DataParameters`: Cost/capacity parameter ranges for data generation
  - Fixed costs, production costs, holding costs
  - Capacity limits, demand parameters
- `SensitivityConfig`: Gamma sensitivity analysis settings

**DH_data_gen.py**: Synthetic data generation
- `SupplyChainData`: Data container class with save/load functionality
- `generate_supply_chain_data()`: Creates random instances
  - Generates 2D coordinates for facilities and customers
  - Calculates Euclidean distances
  - Creates cost parameters and demand patterns
  - Binary demand matrix s_rk: customer r demands product k
- Spatial patterns: Plants (uniform), DCs (donut), Customers (Gaussian)

**DH_master.py**: Master Problem formulation (Gurobi)
- **First-stage variables**: x (plant opening), y (DC opening), z (plant-DC routes), w (DC-customer), β (mode selection), α (mode-route combination)
- **Second-stage variables** (per scenario): A_ij (plant-DC flow), A_jr (DC-customer flow), u (shortage)
- **Objective**: maximize -OC - FC + θ (robust profit)
- **Constraints**:
  - Network topology: single sourcing, mode consistency
  - Operational per scenario: capacity, flow balance, demand satisfaction
  - Optimality cuts: θ ≤ operational profit for each scenario
- **Linearization**: Big-M method for α_jrm * A_jr^k bilinear terms

**DH_sub.py**: Subproblem - Worst-case scenario identification (Gurobi)
- **Dual formulation** of inner maximization problem
- **Variables**:
  - Dual variables: π (plant capacity), σ (DC capacity), ψ (route plant-DC), φ (route DC-customer), γ (demand satisfaction), κ (flow balance)
  - Uncertainty: η^+ (demand increase), η^- (demand decrease)
  - Linearization: p_plus, p_minus (McCormick variables)
- **Objective**: minimize worst-case operational profit
- **Constraints**:
  - Dual feasibility with fixed first-stage variables
  - Uncertainty budget: Σ(η^+ + η^-) ≤ Γ per product
  - McCormick linearization for (η^+ - η^-) * γ
  - Tight bounds: γ^L = -(S+SC), γ^U = S

**DH_algo.py**: Column-and-Constraint Generation algorithm
- `CCGAlgorithm`: Main iterative solver
  - Iterates between Master Problem and Subproblem
  - Upper bound: UB = -OC - FC + θ (from Master)
  - Lower bound: LB = max(-OC - FC + Z_SP) (from Subproblem)
  - Convergence: UB - LB < ε
  - Duplicate scenario detection (prevents infinite loops)
  - History tracking for analysis

**DH_main.py**: Main execution script
- `run_single_gamma()`: Single Gamma value execution
- `run_sensitivity_analysis()`: Iterate over Gamma values
- Automatic result saving and plotting
- Supports both toy and full instances

## Data Files

**Primary data**: `data/DH_data_toy.pkl` and `data/DH_data_full.pkl`
- Generated by `DH_data_gen.py`
- Pickle format containing `SupplyChainData` instance
- All cost parameters, capacities, demands, distances, coordinates

**Legacy data** (from old implementation, may not be compatible):
- `data/data_1.xlsx`: Old Excel-based data
- `data/CenterCust.xlsx`: Customer demand table

## Common Commands

### Run comprehensive tests
```bash
python3 test_all.py
```
Runs 7 comprehensive tests to verify all components (should see 7/7 PASSED)

### Generate data instances
```bash
python3 DH_data_gen.py
```
Creates both toy and full instance data files in `data/`

### Run toy instance (fast, for testing)
```bash
python3 DH_main.py toy
```
Runs sensitivity analysis for Gamma ∈ [0, 1, 2, 3, 4, 5]

### Run full instance
```bash
python3 DH_main.py full
```
Runs sensitivity analysis for Gamma ∈ [0, 10, 20, ..., 100]

### Debug convergence gap
```bash
python3 DH_debug_gap.py toy 0
```
Detailed analysis of Master vs Subproblem calculations

### Test Gurobi installation
```bash
python3 gurobitest.py
```

### Install dependencies
```bash
pip install -r requirements.txt
```

## Algorithm Flow

1. **Initialization**: Create Master Problem with nominal scenario (η = 0)
2. **Iteration loop**:
   - Solve Master Problem → get first-stage solution and θ
   - Calculate upper bound: UB = -OC - FC + θ
   - Solve Subproblem with fixed first-stage → get worst-case scenario (η^+, η^-) and Z_SP
   - Calculate lower bound: LB = max(LB, -OC - FC + Z_SP)
   - Check convergence: if UB - LB < ε, stop
   - Add new scenario to Master Problem
   - Check for duplicate scenarios
3. **Output**: Optimal first-stage solution and robust objective value

## Output Files

Results are saved to `result/` directory:
- `DH_sensitivity_{instance}_{timestamp}.csv`: Main results table
  - Columns: Gamma, Converged, Iterations, Total_Time, Optimal_Value, LB, UB, Gap, Num_Scenarios
- `DH_sensitivity_{instance}_{timestamp}.png`: 4-panel visualization
  - Optimal value vs Gamma
  - Number of scenarios vs Gamma
  - Iterations vs Gamma
  - Computation time vs Gamma

## Key Formulas

**Endogenous demand**:
```
d_rk = Σ_m μ_rk * DI_mk * β_rm + (η^+_rk - η^-_rk) * μ̂_rk
```

**Operational profit** (second-stage):
```
Revenue - HC - TC - PC - SC
where:
  Revenue = S * (demand - shortage)
  HC = holding cost
  TC = transportation cost
  PC = production cost
  SC = shortage cost
```

**Uncertainty set**:
```
η_rk ∈ {-1, 0, 1} (via binary decomposition)
Σ_r (η^+_rk + η^-_rk) ≤ Γ_k (budget constraint per product)
η^+_rk + η^-_rk ≤ 1 (mutual exclusivity)
```

## Documentation Files

### Core Documentation
- **CLAUDE.md** (this file): AI assistant guidance
- **DH_README.md**: Comprehensive implementation documentation
- **DH_QUICKSTART.md**: Quick start and usage guide
- **DH_FINAL_SUMMARY.md**: Project summary and results
- **DH_VERIFICATION.md**: Verification and validation details
- **FORMULA_VERIFICATION.md**: Line-by-line formula verification vs LaTeX
- **CONVERGENCE_GAP_ANALYSIS.md**: Root cause analysis and solutions for convergence issues

### Mathematical References
- **algorithm_framework.tex**: Complete mathematical formulation (LaTeX)
- **for_coding.tex**: Implementation guide (LaTeX)

### Debugging Tools
- **DH_debug_gap.py**: Detailed convergence gap diagnosis tool
- **DH_fix_convergence.py**: Automated fix application for convergence issues

## Important Notes

- All optimization uses **Gurobi** (not CPLEX as in old implementation)
- Gurobi parameters set in `ProblemConfig`: time limit (3600s), MIP gap (1e-4), threads (0 = auto)
- Data uses **0-based indexing** throughout (Python standard)
- Master and Subproblem share the same data instance (no conversion needed)
- Subproblem is recreated each iteration (to avoid stale constraints)
- First-stage solution is fixed in Subproblem via `fix_first_stage()` method

## Problem Dimensions

**Toy instance** (for testing):
- K=1 products, I=2 plants, J=2 DCs, R=5 customers, M=2 modes
- ~10-20 decision variables in first stage
- Fast solve time (~0.1s per iteration)

**Full instance** (production):
- K=3 products, I=5 plants, J=20 DCs, R=100 customers, M=3 modes
- ~30,000+ decision variables
- Expected solve time: minutes to hours depending on Gamma

## Troubleshooting Convergence Issues

If experiencing convergence gaps (UB - LB remains large):

### Quick Diagnosis
```bash
# Run debugging tool to identify exact issue
python3 DH_debug_gap.py toy 0
```

### Common Issues & Solutions

**Issue 1: Solver Tolerance Mismatch** (Most Common)
- **Symptom**: Gap ~1e-4 × objective value, algorithm stalls with duplicate scenarios
- **Solution**: Apply tighter tolerances
  ```bash
  python3 DH_fix_convergence.py
  ```

**Issue 2: Linearization Slack**
- **Symptom**: Debug tool shows X ≠ α×A (linearization error > 1e-4)
- **Solution**: Check Big-M values in DH_master.py:252, consider tighter bounds

**Issue 3: Formula Mismatch**
- **Symptom**: Large gap (>1000), Master and Subproblem profit differ significantly
- **Solution**: Review FORMULA_VERIFICATION.md and CONVERGENCE_GAP_ANALYSIS.md

### Verification Steps
1. Verify all formulas: Check FORMULA_VERIFICATION.md (all ✅)
2. Run diagnosis: `python3 DH_debug_gap.py toy 0`
3. Apply fixes: `python3 DH_fix_convergence.py`
4. Test: `python3 DH_main.py toy`

See **CONVERGENCE_GAP_ANALYSIS.md** for complete root cause analysis and step-by-step solutions.

## Current Status

Implementation complete and mathematically verified ✅. All formulas match LaTeX specifications exactly. Convergence issues are solver-tolerance-related and fixable with DH_fix_convergence.py.

## Legacy Files

All previous implementation files (Adaptive Memetic Algorithm approach, CPLEX-based) have been moved to `Unused/` folder. These are no longer part of the active codebase.
